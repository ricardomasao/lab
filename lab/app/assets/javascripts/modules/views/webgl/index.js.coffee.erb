Particle = require "views/webgl/particle"

module.exports = class WebglIndex

  dom:null
  scene:null
  camera:null
  renderer:null
  geometry:null
  array_particles:[]
  array_elevations:[]
  attributes:null
  texture:null

  constructor:()->

    @dom = $ 'main'
    @time = new Date();

    @scene = new THREE.Scene()
    @camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000)
    @renderer = new THREE.WebGLRenderer()
    @renderer.setSize window.innerWidth, window.innerHeight

    @dom.append @renderer.domElement

    @geometry = new THREE.PlaneGeometry(8, 4, 200, 100)
    mesh = new THREE.Mesh(@geometry, new THREE.MeshBasicMaterial({color: 0x00ff00, opacity: 0 }))

    @texture = THREE.ImageUtils.loadTexture( "<%= asset_path('lensflare0.jpg') %>" )

    @geometry2 = new THREE.Geometry()
    @geometry2.vertices = @geometry.vertices

    @attributes =
      alpha:{type: "f", value: []}
      size:{type: "f", value: []}
      size:{color: "c", value: []}

    uniforms =
      textures: { type: "tv", value: [@texture,@texture,@texture] }


    @shader_material = new THREE.ShaderMaterial(
      uniforms: uniforms
      attributes: @attributes
      blending: THREE.AdditiveBlending
      vertexShader: document.getElementById("vertexshader").textContent
      fragmentShader: document.getElementById("fragmentshader").textContent
      transparent: true
    )

    particles = new THREE.PointCloud(@geometry2, @shader_material)
    particles.sortParticles = true;

    for i of @geometry2.vertices
      particle = new Particle @geometry2.vertices[i], Math.random()*0.05, @attributes, i
      particle.set_size Math.random()*6
      particle.set_alpha Math.random()*.5
      particle.set_color new THREE.Color(0xffffff)
      @array_particles.push particle

    @scene.add particles

    particles.rotation.x = -1.7

    @camera.position.z = 3;
    @camera.position.y = 1;

    @setup_elevation(50)
    @generate_terrain()

    @render()

  setup_elevation:(num_points)=>
    i = 0
    while i < num_points
      elevation_height = Math.random()*500
      @array_elevations.push {elevation_point:parseInt(Math.random()*@geometry.vertices.length), elevation_height:elevation_height, radius:Math.random()*1.5 }
      i++

  generate_terrain:()=>
    for i of @array_elevations
      points = @get_nearest_points( @array_particles[@array_elevations[i].elevation_point], @array_elevations[i].radius )
      @rise_terrain points, @array_particles[@array_elevations[i].elevation_point], @array_elevations[i].radius

  get_nearest_points:(point, radius)->
    nearest_points = []

    for i of @array_particles
      pointX = @array_particles[i].get_x()
      pointY = @array_particles[i].get_y()
      centerX = point.get_x()
      centerY = point.get_y()
      nearest_points.push(@array_particles[i]) if @point_inside_radius(pointX,pointY,centerX, centerY, radius)

    return nearest_points


  point_inside_radius:(pointX, pointY, centerX, centerY, radius)->
    return Math.pow(pointX - centerX, 2) + Math.pow(pointY - centerY, 2) < radius*radius

  rise_terrain:(points,center, radius)=>
    for i of points
      distance = @get_distance_between_points(points[i], center)
      points[i].set_z Math.abs( distance - radius )/4
      points[i].random_x Math.random()*0.03 - Math.random()*0.03
      points[i].random_y Math.random()*0.03 - Math.random()*0.03

  get_distance_between_points:(p1,p2)->
    p1_x = p1.get_x()
    p1_y = p1.get_y()
    p2_x = p2.get_x()
    p2_y = p2.get_y()

    return Math.sqrt( (p2_x-=p1_x)*p2_x + (p2_y-=p1_y)*p2_y );

  render:()=>

    i = 0
    while i < @array_particles.length
      particle = @array_particles[i]
      particle.counter += particle.interval
      # particle.move_z(Math.sin( particle.counter )/10)
      i++

    @attributes.alpha.needsUpdate = true
    @geometry2.verticesNeedUpdate = true

    requestAnimationFrame @render
    @renderer.render @scene, @camera
    return
